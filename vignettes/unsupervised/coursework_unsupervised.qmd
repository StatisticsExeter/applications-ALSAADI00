---
title: "Coursework: Unsupervised Learning – Road Collision Clustering"
format: html
---

# Introduction

This report summarises the work I did using unsupervised learning techniques. The following command was used:

```
doit -f dodo_unsupervised.py
```

The workflow produced exploratory data analysis, hierarchical clustering, KMeans clustering, and an additional DBSCAN method for extra credit.

---

# Exploratory Data Analysis

The exploratory data analysis step creates an initial two-dimensional view of the local authorities based on their collision statistics. The code below embeds the PCA scatter plot produced by the EDA task. Each point represents a local authority, and its position is determined by the first two principal components of the standardised collision variables. This helps reveal broad patterns such as clusters of authorities with similar collision profiles and isolated authorities that behave differently.

```{python}
#| echo: false
import sys
import os
project_root =os.path.abspath("../..")
sys.path.append(project_root)
from course.utils import find_project_root
from IPython.display import IFrame

base_dir = find_project_root()
scatter_path=base_dir / "data_cache" / "vignettes" / "unsupervised_classification" / "scatterplot.html"

IFrame(src=str(scatter_path), width="100%", height=500)
```

The code that generated this figure reads the pre-processed `la_collision.csv` file, standardises the numeric features, applies PCA, and then uses a scatter plotting helper to display the projected points.

---

# Hierarchical Clustering

## Dendrogram

The dendrogram below shows how local authorities are merged step by step into larger groups. The vertical axis represents the distance at which clusters are joined, so long branches indicate groups that are relatively distinct before they are merged.

```{python}
#| echo: false
from course.utils import find_project_root
from IPython.display import IFrame

base_dir = find_project_root()
dend_path=base_dir / "data_cache" / "vignettes" / "unsupervised_classification" / "dendrogram.html"

IFrame(src=str(dend_path), width="100%", height=500)
```

The code computes a distance matrix form the standardised data, runs hierarchical clustering, and then plots the resulting tree structure.

## Selected Groups

The code cuts the tree at a chosen height to obtain a set of groups. These groups are then projected onto the first two principal components and coloured by cluster label. The next embedded plot shows those selected hierarchical groups on the PCA map.

```{python}
#| echo: false
from course.utils import find_project_root
from IPython.display import IFrame

base_dir = find_project_root()
hscatter_path=base_dir / "data_cache" / "vignettes" / "unsupervised_classification" / "hscatter.html"

IFrame(src=str(hscatter_path), width="100%", height=500)
```

Compact and well-separated coloured regions indicate groups of local authorities that share similar collision characteristics according to the hierarchical model.

---

# KMeans Clustering

 The code in `kmeans.py` standardises the data, runs KMeans, projects the cluster assignments into the PCA space, and saves interactive HTML plots. Below the outputs for *k* = 4.

### K = 4

The plot below displays the four-cluster solution.

```{python}
#| echo: false
from course.utils import find_project_root
from IPython.display import IFrame

base_dir = find_project_root()
kscatter_path=base_dir / "data_cache" / "vignettes" / "unsupervised_classification" / "kscatter.html"

kcentroid1_path=base_dir / "data_cache" / "vignettes" / "unsupervised_classification" / "kcentroids1.html"

kcentroid2_path=base_dir / "data_cache" / "vignettes" / "unsupervised_classification" / "kcentroids2.html"

IFrame(src=str(kscatter_path), width="100%", height=500)
IFrame(src=str(kcentroid1_path), width="100%", height=500)
IFrame(src=str(kcentroid2_path), width="100%", height=500)
```

---

# Additional Method (Extra Credit): DBSCAN

To extend the analysis and obtain extra credit, I implemented a density-based clustering method, DBSCAN, in a new module (`dbscan.py`). The implementation closely follows the structure of `kmeans.py`: it reads the same `la_collision.csv` file, standardises the variables, fits a DBSCAN model, and then uses PCA together with the existing plotting helper to create a scatter plot of the resulting clusters.

DBSCAN does not require specifying the number of clusters in advance. The plot below shows the PCA projection coloured by DBSCAN labels. Authorities labelled as noise are highlighted as a separate category, giving a different view of unusual or atypical collision patterns.

```{python}
#| echo: false
from course.utils import find_project_root
from IPython.display import IFrame

base_dir = find_project_root()
dbscan_scatter_path=base_dir / "data_cache" / "vignettes" / "unsupervised_classification" / "dbscan_scatter.html"

IFrame(src=str(dbscan_scatter_path), width="100%", height=500)
```

---

# Summary

In this coursework, I:

- Generated an exploratory PCA scatter plot to get an initial view of how local authorities relate based on collision statistics.
- Applied hierarchical clustering, produced a dendrogram, and visualised selected groups on the PCA map.
- Ran KMeans clustering for *k* = 4.
- Implemented a DBSCAN clustering method to obtain a density-based view of the data, including noise points.

---

# Record of AI Use

| **Date**       | **AI tool used** | **Purpose**                                | **Prompt**                                 | **Hyperlink to output (where possible)** | **Section of work used for** |
|----------------|------------------|--------------------------------------------|--------------------------------------------|------------------------------------------|-------------------------------|
| 12/12/2025    | ChatGPT          | Getting guidance on how to structure my DBSCAN implementation so it followed the same style as my existing kmeans.py code | “I want to add DBSCAN as an extra method. Can you show me how to base the DBSCAN code on my current kmeans.py structure?” | *N/A* | Extra-credit DBSCAN method